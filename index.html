<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Sales Navigation</title>
    <link rel="stylesheet" href="index.css">
    <link rel="icon" type="image/x-icon" href="SaleNav.ico">
    <script src="opencv.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.1/dist/tesseract.min.js"></script>
</head>
<body>
    <div id="PopUpBox"></div>
    <div class="InfoBtn" id="inactiveBtn" onclick="DisplayInfo()">i</div>
    <span id="offWindowBtn" style="display: none;" onclick="DisplayInfo()"></span>
    <section id="InfoDisplay" style="display: none;">
        <div id="InfoDisText">
            <div class="InfoContent" id="info_content_first">
                <h2>Sales Navigation Manual</h2>
                <h3>Basics:</h3>
                <p>Screenshot your Sales Navigator & paste it inside this webpage. Click the convert button to convert your screenshots into raw contact data. The resulting text will be automatically copied to your clipboard.</p>
            </div>
            <div class="InfoContent" id="info_content_third">
                <h3>Single & double click the image:</h3>
                <p><b>When single clicking</b> the image you pasted you will see the masked image containing the information you will get in string format when clicking the convert button.</p>
                <p><b>When double clicking</b> the image you pasted you will remove that image from your collection.</p>
            </div>
            <div class="InfoContent" id="info_content_second">
                <h3>Set page theme:</h3>
                <p>You can change your color mode by clicking on the title of the page</p>
            </div>
        </div>
        <div id="InfoDisVis">

        </div>
    </section>

    <h1 id="LightModus" onclick="changeLightModus('dark')" ondblclick="changeWorkModus('ScrnTxt')">Sales Navigation</h1> <!-- ScrnSafe -->
    <section id="Images"><h2 id="CrtlPlaceholder">Crtl + V / Cmnd + V</h2></section>
    <section id="Controls">
        <button onclick="conversion()">Convert</button>
    </section>
</body>
</html>

<script>
    let ScrnShotCounter = 0;
    let counter = false;
    //CHECK IF BROWSER COLOR SCHEME IS SET TO DARK: IF SO SET WEBPAGE COLOR SCHEME ALSO TO BLACK
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        changeLightModus('dark');
    }

    //LIGHT MODUS CHANGE FUNCTION: WITH 'MODUS' = 'dark' OR 'light' AS INPUT;
    function changeLightModus(modus) {
        switch (modus) {
            case 'dark':
                //CHANGE INPUT STATUS TO LIGHT MODUS ON BUTTON
                document.getElementById('LightModus').setAttribute("onclick", "changeLightModus('light')");
                //CHANGE CSS GLOBAL VARIABLES TO DARK THEME
                document.documentElement.style.setProperty("--col-background", 'black');
                document.documentElement.style.setProperty("--col-background-sub", '#141414');
                document.documentElement.style.setProperty("--col-popup", '#FFFFFF');
                document.documentElement.style.setProperty("--col-popup-txt", 'black');
                document.documentElement.style.setProperty("--col-txt", '#FFFFFF');
                document.documentElement.style.setProperty("--col-border", '#FFFFFF');
                document.documentElement.style.setProperty("--col-InfoDisplay", 'rgba(255,255,255,0.98)');
                document.documentElement.style.setProperty("--col-InfoDisplay-sub", 'rgba(0,0,0,0.03)');


                break;
            case 'light':
                //CHANGE INPUT STATUS TO LIGHT MODUS ON BUTTON
                document.getElementById('LightModus').setAttribute("onclick", "changeLightModus('dark')");
                //CHANGE CSS GLOBAL VARIABLES TO DARK THEME
                document.documentElement.style.setProperty("--col-background", '#FFFFFF');
                document.documentElement.style.setProperty("--col-background-sub", '#F5F5F5');
                document.documentElement.style.setProperty("--col-popup", 'black');
                document.documentElement.style.setProperty("--col-popup-txt", '#FFFFFF');
                document.documentElement.style.setProperty("--col-txt", 'black');
                document.documentElement.style.setProperty("--col-border", 'black');
                document.documentElement.style.setProperty("--col-InfoDisplay", 'rgba(0,0,0,0.98)');
                document.documentElement.style.setProperty("--col-InfoDisplay-sub", 'rgba(255,255,255,0.03)');

                break;
            default:
                //IF AN ERROR OCCURS IT SHOULD DEFAULT ITSELF TO LIGHT MODUS
                changeLightModus('light');
        }
    }

    //POP UP WINDOW FUNCTION
    function PopUpWindow(DisplayText) {
        PopUpBox = document.getElementById('PopUpBox');
        PopUpBox.innerText = DisplayText;

        if (counter) {
            PopUpBox.style.animation = 'PopUp1 4s';
            counter = false;
        }
        else {
            PopUpBox.style.animation = 'PopUp2 4s';
            counter = true;
        }
    }

    function findCloseValues(arr, rangeValue, WantDupes = false) {
        arr.sort((a, b) => a - b);
        let closeValues = [];
        let currentGroup = [arr[0]];

        for (let i = 1; i < arr.length; i++) {
            if (arr[i] - arr[i - 1] <= rangeValue) {
                currentGroup.push(arr[i]);
                if (currentGroup.length === 2) {
                    if (currentGroup[0] !== currentGroup[1] || WantDupes) {
                        closeValues.push([...currentGroup]);
                    }
                    currentGroup = [arr[i]];
                }
            } else {
                currentGroup = [arr[i]];
            }
        }

        return closeValues;
    }

    function findIndexesOfRepeatedValue(arr, value) {
        let indexes = [];

        // Iterate through the array to find indexes of the repeated value
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === value) {
                indexes.push(i);
            }
        }

        return indexes;
    }

    window.addEventListener("paste", function (e) {
        let item = Array.from(e.clipboardData.items).find(x => /^image\//.test(x.type));
        const Placeholder = document.getElementById('CrtlPlaceholder');


        let ID;
        if (OlderImageBool) {
            OlderImageBool = false;
            ID = ScrnShotCounter - OlderImageDist;
        } else {
            ID = ScrnShotCounter;
        }

        if (Placeholder && item) {
            Placeholder.remove();
        }

        let blob = item.getAsFile();
        let img = new Image();

        img.onload = function () {
            CreateImageFolderElements(this, ID);
        };

        img.src = URL.createObjectURL(blob);
        CreateMaskedImageFromBlob(blob).then(MatImage => {
            let bgr_img = MatImage;
            let gray_img = new cv.Mat();
            cv.cvtColor(bgr_img, gray_img, cv.COLOR_RGBA2GRAY, 0);

            // Apply edge detection with different thresholds
            let edges1 = new cv.Mat();
            let edges2 = new cv.Mat();
            cv.Canny(gray_img, edges1, 0, 255, 3);
            cv.Canny(gray_img, edges2, 0, 145, 3);

            // Subtract the edge images
            let result = new cv.Mat();
            cv.subtract(edges2, edges1, result);

            // Detect vertical lines using morphological operations
            let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(1, 40));
            let verticalLines = new cv.Mat();
            cv.morphologyEx(result, verticalLines, cv.MORPH_OPEN, kernel);

            // Find contours and extract x-coordinates
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(verticalLines, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            let xCoordinates = [];
            for (let i = 0; i < contours.size(); i++) {
                let boundingRect = cv.boundingRect(contours.get(i));
                xCoordinates.push(boundingRect.x);
            }

            // Find the contact window coordinates
            const closeValues = findCloseValues(xCoordinates, 5, false);
            const X1_Contact_Window = closeValues[0][0];
            const X2_Contact_Window = closeValues.at(-1)[1];

            // Crop the image based on the contact window
            let rect = new cv.Rect(X1_Contact_Window, 0, X2_Contact_Window - X1_Contact_Window, gray_img.rows);
            let cropped = gray_img.roi(rect);
            let cropped_bgr = bgr_img.roi(rect);

            // Apply GaussianBlur to reduce noise
            let blurred_img = new cv.Mat();
            cv.GaussianBlur(cropped, blurred_img, new cv.Size(9, 9), 2, 2);

            // Detect circles using HoughCircles
            let circles = new cv.Mat();
            cv.HoughCircles(blurred_img, circles, cv.HOUGH_GRADIENT, 1, blurred_img.rows / 16, 100, 30, 10, 100);

            // Extract circle centroids
            let Xs = [], Ys = [];
            for (let i = 0; i < circles.cols; ++i) {
                Xs.push(circles.data32F[i * 3]);
                Ys.push(circles.data32F[i * 3 + 1]);
            }

            // Find repeated x and y coordinates
            let Xrepeated = findCloseValues(Xs, 2, true);
            let Yrepeated = findCloseValues(Ys, 25);
            const WidthFactor = 3 / 4;
            const HeightFactor = 2.5;

            // Calculate line height and create content sections
            let LineHeight = (parseInt(Yrepeated[1]) - parseInt(Yrepeated[0])) / HeightFactor;
            let ContentSections = new cv.Mat.zeros(cropped_bgr.rows, cropped_bgr.cols, cropped_bgr.type());

            for (let j = 0; j < Yrepeated.length; j++) {
                let p1 = new cv.Point(parseInt(Xrepeated[0][0]), parseInt(Yrepeated[j][0]));
                let p2 = new cv.Point(parseInt(Xrepeated.at(-1)[1]) * WidthFactor, parseInt(Yrepeated[j][0]));
                cv.line(ContentSections, p1, p2, [255, 255, 255, 255], parseInt(LineHeight));
            }

            // Apply bitwise AND to combine content sections with the cropped image
            cv.bitwise_and(ContentSections, cropped_bgr, cropped_bgr);

            // Display the result
            cv.imshow(`ScrnShotMask${ID}`, cropped_bgr);

            // Clean up
            gray_img.delete();
            blurred_img.delete();
            circles.delete();
            edges1.delete();
            edges2.delete();
            result.delete();
            verticalLines.delete();
            contours.delete();
            hierarchy.delete();
            ContentSections.delete();

        }).catch(err => {
            console.error('Error:', err);
        });

        ScrnShotCounter++;
    });

    let OlderImageBool = false;
    let OlderImageDist = 0;

    function CreateImageFolderElements(New_ScrnShtElement, ID) {
        const ImageFolfderParent = document.getElementById('Images');
        const ImageFolder = document.createElement('div');
        const ScreenShotMask = document.createElement('canvas');
        ImageFolder.setAttribute('class', 'ScreenShotFolder');
        ImageFolder.setAttribute('id', `ScrnShotFolder${ID}`);
        ImageFolder.setAttribute('ondblclick', `DeleteThisScrnShot('ScrnShotFolder${ID}')`);

        ScreenShotMask.setAttribute('class', 'ScreenShotMask');
        ScreenShotMask.setAttribute('id', `ScrnShotMask${ID}`);
        ScreenShotMask.style.display = 'none';
        ScreenShotMask.setAttribute('onclick', `ShowMask(${ID}, false)`);

        New_ScrnShtElement.id = `ScrnShotImage${ID}`;
        New_ScrnShtElement.setAttribute('class', 'ScreenShotImage');
        New_ScrnShtElement.setAttribute('onclick', `ShowMask(${ID}, true)`);
        ImageFolfderParent.appendChild(ImageFolder);
        ImageFolder.appendChild(ScreenShotMask);
        ImageFolder.appendChild(New_ScrnShtElement);

    }

    function DeleteThisScrnShot(ID) {
        const ID_short = ID.slice(-1);
        if (ID_short < ScrnShotCounter) {
            OlderImageBool = true;
            OlderImageDist = ScrnShotCounter - ID_short;
        } 
        document.getElementById(ID).remove();
        ScrnShotCounter--;

        if (ScrnShotCounter == 0) {
            const ImagesParent = document.getElementById('Images');
            const Placeholder = document.createElement('h2');
            Placeholder.id = 'CrtlPlaceholder';
            Placeholder.innerText = 'Crtl + V / Cmnd + V';
            ImagesParent.appendChild(Placeholder);
        }
    }

    async function CreateMaskedImageFromBlob(blob) {
        return new Promise((resolve, reject) => {
            let img = new Image();
            img.src = URL.createObjectURL(blob);
            img.onload = function () {
                let canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                let ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, img.width, img.height);
                let imgData = ctx.getImageData(0, 0, img.width, img.height);
                let MatImage = cv.matFromImageData(imgData);
                resolve(MatImage);
            };
            img.onerror = function (err) {
                reject(err);
            };
        });
    }

    async function extractTextFromCanvas(canvas) {
        // Convert the canvas to a data URL
        const dataURL = canvas.toDataURL('image/png');

        // Use Tesseract.js to recognize text from the image
        const worker = Tesseract.createWorker({
            logger: m => console.log(m) // Add logger here to see progress
        });

        await worker.load();
        await worker.loadLanguage('eng');
        await worker.initialize('eng');

        try {
            const { data: { text } } = await worker.recognize(dataURL);
            return text;
        } catch (error) {
            console.error('Error recognizing text:', error);
            return null;
        } finally {
            await worker.terminate(); // Terminate the worker after processing
        }
    }

    function ShowMask(ID, ImgStatus) {
        if (ImgStatus) {
            document.getElementById(`ScrnShotImage${ID}`).style.display = 'none';
            document.getElementById(`ScrnShotMask${ID}`).style.display = 'unset';
        } else {
            document.getElementById(`ScrnShotImage${ID}`).style.display = 'unset';
            document.getElementById(`ScrnShotMask${ID}`).style.display = 'none';
        }
    }

    function DisplayInfo() {
        let InfoStatus = document.getElementsByClassName('InfoBtn')[0].id;

        if (InfoStatus == 'inactiveBtn') {
            document.getElementsByClassName('InfoBtn')[0].id = 'activeBtn';
            document.getElementById('InfoDisplay').style.display = 'unset';
            document.getElementById('offWindowBtn').style.display = 'unset';
        } else {
            document.getElementsByClassName('InfoBtn')[0].id = 'inactiveBtn';
            document.getElementById('InfoDisplay').style.display = 'none';
            document.getElementById('offWindowBtn').style.display = 'none';
        }
    }

    function ImageStringtoArray(Imagestr) {
        let arr = Imagestr.split(' - ');

        return arr.flatMap(str => {
            // Split by newlines and other non-word characters, but keep names and titles together
            return str.split(/[\n\/]+/)
                .map(part => part.trim())
                .filter(Boolean)
                .filter(part => !/[©\d]/.test(part)); // Remove elements containing numbers
        });
    }

    function conversion() {
        const Canvases = document.getElementsByClassName('ScreenShotMask');

        if (Canvases.length === 0) {
            return;
        }


        let txt = [];
        let promises = [];

        for (let i = 0; i < Canvases.length; i++) {
            promises.push(
                extractTextFromCanvas(Canvases[i]).then(text => {
                    const outputString = ImageStringtoArray(text);
                    txt.push(outputString);
                })
            );
        }

        Promise.all(promises).then(() => {
            navigator.clipboard.writeText(txt.join('\n'));
            PopUpWindow('All contact info from the screenshots are copied to your clipboard');
        });
    }

</script>